Linear Algebra
==============

.. module: best.linalg
    :synopsis: Some linear algebra routines.

The linear module (:mod:`best.linalg`)
defines several functions that cannot be found in numpy or
scipy but are extremely useful in various Bayesian problems.

.. function:: best.linalg.kron_prod(A, x)

    Multiply a Kronecker product of matrices with a vector.

    The function computes the product:
        .. math::
            \mathbf{y} = (\otimes_{i=1}^s \mathbf{A}_i) \mathbf{x},

    where :math:`\mathbf{A}_i` are suitable matrices.
    The characteristic of the routine is that it does not form the
    Kronecker product explicitly. Also, :math:`\mathbf{x}` can be a
    matrix of appropriate dimensions. Of course, it will throw an
    exception if you don't have the dimensions right.

    :param A: Represents the Kronecker product of matrices.
    :type A: a matrix or a collection -list or tuple- of 2D numpy arrays.
    :param x: The vector you want to multiply the matrix with.
    :type x: numpy 1D or 2D array.
    :return: The product.
    :rtype: A 2D numpy array. If x was 1D, then it represents a columnt\
            matrix (i.e., a vector).

    Here is an example:

    >>> import numpy as np
    >>> import best.linalg
    >>> A1 = np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])
    >>> A2 = A1
    >>> A = (A1, A2)
    >>> x = np.random.randn(A1.shape[1] * A2.shape[1])
    >>> y = best.linalg.kron_prod(A, x)

    You should compare the result with:

    >>> ...
    >>> z = np.dot(np.kron(A1, A2), x)

    The last ones forms the Kronecker product explicitly and uses much more
    memory.

.. function:: best.linalg.kron_solve(A, y)

    Solve a linear system involving Kronecker products.

    The function solves the following linear system:
        .. math::
            (\otimes_{i=1}^s\mathbf{A}_i)\mathbf{x} = \mathbf{y},

    where :math:`\mathbf{A}_i` are suitable matrices and
    :math:`\mathbf{y}` is a vector or a matrix.

    :param A: Represents a Kronecker product of matrices.
    :type A: a matrix or a collection -list or tuple- of 2D numpy arrays.
    :param y: The right hand side of the equation.
    :type y: a 1D or 2D numpy array
    :returns: The solution of the linear system.
    :rtype: A numpy array of the same type as y.

    Here is an example:

    >>> A1 = np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])
    >>> A2 = A1
    >>> A = (A1, A2)
    >>> y = np.random.randn(A1.shape[1] * A2.shape[1])
    >>> x = best.linalg.kron_solve(A, y)

    Compare this with:

    >>> ...
    >>> z = np.linalg.solve(np.kron(A1, A2), y)

    which actually builds the Kronecker product.

.. function:: best.linalg.update_cholesky(L, B, C)

    Updates the Cholesky decomposition of a matrix.

    We assume that :math:`\mathbf{L}` is the lower Cholesky decomposition
    of an :math:`n\times n` matrix :math:`\mathbf{A}`, and we want to
    calculate the Cholesky decomposition of the :math:`(n+m)\times (n+m)`
    matrix:

    .. math::
        \mathbf{A}' = \left(\begin{array}{cc}\mathbf{A}& \mathbf{B}\\
        \mathbf{B}^T & \mathbf{C} \end{array}\right)

    It can be easily shown that the Cholesky decomposition of
    :math:`\mathbf{A}'` is given by:

    .. math::
        \mathbf{L}' = \left(\begin{array}{cc}\mathbf{L}& \mathbf{0}\\
        \mathbf{D}_{21} & \mathbf{D}_{22}\end{array}\right)

    where

    .. math::
        \mathbf{B} = \mathbf{L} \mathbf{D}_{21}^T

    and

    .. math::
        \mathbf{D}_{22} \mathbf{D}_{22} = \mathbf{C}
        - \mathbf{D}_{21}\mathbf{D}_{21}^T.

    :param L: The Cholesky decomposition of the original matrix.
    :type L: 2D numpy array
    :param B: The :math:`n\times m` upper right part of the new matrix.
    :type B: 2D numpy array
    :param C: The :math:`m\times m` bottom diagonal part of the new matrix.
    :type C: 2D numpy array
    :returns: The lower Cholesky decomposition of the new matrix.
    :rtype: 2D numpy array

.. function:: best.linalg.update_cholesky_linear_system(x, L_new, z)

    Update the solution of Cholesky-solved linear system.

    Assume that originally we had an :math:`n\times n` lower triangular
    matrix :math:`\mathbf{L}` and that we have already solved the linear
    system:

    .. math::
        \mathbf{L} \mathbf{x} = \mathbf{y},

    Now, we wish to solve the linear system:

    .. math::
        \mathbf{L}'\mathbf{x}' = \mathbf{y}',

    where :math:`\mathbf{L}` is again lower triangular matrix whose
    top :math:`n \times n` component is identical to :math:`\mathbf{L}`
    and :math:`\mathbf{y}'` is :math:`(\mathbf{y}, \mathbf{z})`. The
    solution is:

    .. math::
        \mathbf{x}' = (\mathbf{x}, \mathbf{x}_u),

    where :math:`\mathbf{x}_u` is the solution of the triangular system:

    .. math::
        \mathbf{L}_{22}' * \mathbf{x}_u = \mathbf{z} - \mathbf{L}_{21}' \mathbf{x},

    where :math:`\mathbf{L}_{22}'` is the lower :math:`m\times m`
    component of :math:`\mathbf{L}'` and :math:`\mathbf{L}_{21}'` is the
    :math:`m\times n` bottom left component of :math:`\mathbf{L}'`.

    :param x: The solution of the first Cholesky system.
    :type x: 1D or 2D numpy array
    :param L_new: The new Cholesky factor (see :func:`best.linalg.update_cholesky`)
    :type L_new: 2D numpy array
    :param z: The new part of :math:`\mathbf{y}`.
    :type z: numpy array of the same type as x
    :returns: The solution of the linear system.
    :rtype: numpy array of the same type as x